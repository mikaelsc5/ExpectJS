<!DOCTYPE html>

<html>
<head>
  <title>ExpectJS</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="expect.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>ExpectJS</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>ExpectJS 0.0.9</p>
<p>(c) 2013 Mikael Blomberg
ExpectJS may be freely distributed under the MIT license.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="keyword">function</span>(){</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Initial Setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Save a reference to the global object (<code>window</code> in the browser, <code>exports</code>
on the server).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> root = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Save the previous value of the <code>expect</code> variable, so that it can be
restored later on, if <code>noConflict</code> is used.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> previousExpect = root.expect;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The top-level namespace. All public ExpectJS classes and modules will
be attached to this. Exported for both the browser and the server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> expect = ExpectJS;
  <span class="keyword">if</span> ((<span class="keyword">typeof</span> module === <span class="string">"object"</span>) &amp;&amp;
      (<span class="keyword">typeof</span> module.exports === <span class="string">"object"</span>)) {
    module.exports = expect;
  } <span class="keyword">else</span> {
    root.expect = expect;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Current version of the library. Keep in sync with <code>package.json</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  expect.VERSION = <span class="string">'0.0.9'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Runs ExpectJS in <em>noConflict</em> mode, returning the <code>expect</code> variable
to its previous owner. Returns a reference to this expect object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  expect.noConflict = <span class="keyword">function</span>() {
    root.expect = previousExpect;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>ExpectJS constructor</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="keyword">function</span> <span class="title">ExpectJS</span><span class="params">(expression)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>ExpectJS object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> prototype = Object.create(<span class="literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>ExpectJS &#39;not&#39; property to negate the matcher</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    prototype.not = Object.create(<span class="literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>ExpectJS failed object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> failed = {
      <span class="string">"message"</span> : <span class="literal">null</span>,
      <span class="string">"actual"</span> : expression,
      <span class="string">"expected"</span> : <span class="literal">null</span>
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A function for adding more matchers to ExpectJS.
The added function will have the given name and
negated in the &#39;not&#39; property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">addMatcher</span><span class="params">(name, matcherFunction, notMatcherFunction)</span> {</span>
      prototype[name] = matcherFunction;
      prototype.not[name] = notMatcherFunction;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>A function for comparing &#39;actual&#39; with &#39;expected&#39; using the identity operator.
The comparison is negated when &#39;not&#39; is true.
Returns itself for chaining.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">identityComparison</span><span class="params">(actual, expected, not)</span> {</span>
      <span class="keyword">if</span> (((not === <span class="literal">true</span>) &amp;&amp; (actual !== expected)) ||
          ((not !== <span class="literal">true</span>) &amp;&amp; (actual === expected))) {
        <span class="keyword">return</span> prototype;
      } <span class="keyword">else</span> {
        failed.message = <span class="string">"Expected "</span> + expected + <span class="string">" to equal "</span> + actual;
        failed.expected = expected;
        <span class="keyword">throw</span> failed;
      }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>A function for recursively comparing array values with &#39;expected&#39; using the identity operator.
The comparison is negated when &#39;not&#39; is true.
Returns itself for chaining.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="keyword">function</span> <span class="title">recursiveComparison</span><span class="params">(array, expected, not)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Store the index for the last value in the array to compare
when all elements in the array has been checked</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> lastIndex = array.length - <span class="number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Use recursion function to utilizes the closure for accessing the values</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">var</span> recursion = <span class="keyword">function</span>(index) {
        <span class="keyword">var</span> value = array[index];</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Halt condition:
All elements in the array has been checked and none was the &#39;expected&#39; value or
the &#39;not&#39; expected value has been found</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> (((not !== <span class="literal">true</span>) &amp;&amp; (lastIndex === index)) ||
            ((not === <span class="literal">true</span>) &amp;&amp; (value === expected))) {
          failed.message = <span class="string">"Expected to find "</span> + expected + <span class="string">" in "</span> + array;
          failed.expected = expected;
          <span class="keyword">throw</span> failed;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Pass condition:
The &#39;expected&#39; value has been found or
all elements in the array has been checked and none was the &#39;not&#39; expected value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="keyword">else</span> <span class="keyword">if</span> (((not !== <span class="literal">true</span>) &amp;&amp; (value === expected)) ||
                   ((not === <span class="literal">true</span>) &amp;&amp; (lastIndex === index))) {
          <span class="keyword">return</span> prototype;
        } <span class="keyword">else</span> {
          <span class="keyword">return</span> recursion(index + <span class="number">1</span>);
        }
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Execute the recursion function to start from the first element in the array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      recursion(<span class="number">0</span>);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2>expect(&#39;expression&#39;).toBe</h2>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The &#39;toBe&#39; matcher compares &#39;expression&#39; and &#39;expected&#39; with ===.
&#39;not.toBe&#39; compares &#39;expression&#39; and &#39;exprected&#39; with !==.
The match passes if they are the same object or primitives and
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toBe'</span>, <span class="keyword">function</span>(expected) {
      <span class="keyword">return</span> identityComparison(expression, expected, <span class="literal">false</span>);
    }, <span class="function"><span class="keyword">function</span> <span class="params">(expected)</span> {</span>
      <span class="keyword">return</span> identityComparison(expression, expected, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <h2>expect(&#39;expression&#39;).toBeDefined</h2>

            </div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>The &#39;toBeDefined&#39; matcher compares &#39;expression&#39; with !== undefined.
&#39;not.toBeDefined&#39; compares &#39;expression&#39; with === undefined.
The match passes if they are the same object or primitives and
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toBeDefined'</span>, <span class="keyword">function</span>() {
      <span class="keyword">var</span> notDefined; <span class="comment">// notDefined is deliberately not defined, to be evaluated as undefined.</span>
      <span class="keyword">return</span> identityComparison(expression, notDefined, <span class="literal">true</span>);
    }, <span class="keyword">function</span>() {
      <span class="keyword">var</span> notDefined; <span class="comment">// notDefined is deliberately not defined, to be evaluated as undefined.</span>
      <span class="keyword">return</span> identityComparison(expression, notDefined, <span class="literal">false</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2>expect(&#39;expression&#39;).toBeUndefined</h2>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>The &#39;toBeUndefined&#39; matcher compares &#39;expression&#39; with === undefined.
&#39;not.toBeUndefined&#39; compares &#39;expression&#39; with !== undefined.
The match passes if they are the same object or primitives and
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toBeUndefined'</span>, <span class="keyword">function</span>() {
      <span class="keyword">var</span> notDefined; <span class="comment">// notDefined is deliberately not defined, to be evaluated as undefined.</span>
      <span class="keyword">return</span> identityComparison(expression, notDefined, <span class="literal">false</span>);
    }, <span class="keyword">function</span>() {
      <span class="keyword">var</span> notDefined; <span class="comment">// notDefined is deliberately not defined, to be evaluated as undefined.</span>
      <span class="keyword">return</span> identityComparison(expression, notDefined, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2>expect(&#39;expression&#39;).toBeNull</h2>

            </div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>The &#39;toBeNull&#39; matcher compares &#39;expression&#39; with === null.
&#39;not.toBeNull&#39; compares &#39;expression&#39; with !== null.
The match passes if they are the same object or primitives and
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toBeNull'</span>, <span class="keyword">function</span>() {
      <span class="keyword">var</span> isNull = <span class="literal">null</span>;
      <span class="keyword">return</span> identityComparison(expression, isNull, <span class="literal">false</span>);
    }, <span class="keyword">function</span>() {
      <span class="keyword">var</span> isNull = <span class="literal">null</span>;
      <span class="keyword">return</span> identityComparison(expression, isNull, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>The &#39;toBeThruthy&#39; matcher compares !!&#39;expression&#39; with === true.
&#39;not.toBeThruthy&#39; compares !!&#39;expression&#39; with !== true.
The match passes if they are both true
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toBeTruthy'</span>, <span class="keyword">function</span>() {
      <span class="keyword">return</span> identityComparison(!!expression, <span class="literal">true</span>, <span class="literal">false</span>);
    }, <span class="keyword">function</span>() {
      <span class="keyword">return</span> identityComparison(!!expression, <span class="literal">true</span>, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>The &#39;toBeFalsy&#39; matcher compares !&#39;expression&#39; with === true.
&#39;not.toBeFalsy&#39; compares !!&#39;expression&#39; with !== true.
The match passes if they are both false
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toBeFalsy'</span>, <span class="keyword">function</span>() {
      <span class="keyword">return</span> identityComparison(!expression, <span class="literal">true</span>, <span class="literal">false</span>);
    }, <span class="keyword">function</span>() {
      <span class="keyword">return</span> identityComparison(!expression, <span class="literal">true</span>, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>The &#39;toEqual&#39; matcher compares &#39;expression&#39; with the &#39;expected&#39; value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toEqual'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(expected)</span> {</span>
      <span class="keyword">return</span> identityComparison(expression, expected, <span class="literal">false</span>);
    }, <span class="function"><span class="keyword">function</span> <span class="params">(expected)</span> {</span>
      <span class="keyword">return</span> identityComparison(expression, expected, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>The &#39;toContain&#39; matcher searches the &#39;expression&#39; Array for the &#39;expected&#39; value.
&#39;not.toContain&#39; searches the &#39;expression&#39; Array not to contain the &#39;expected&#39; value.
The match passes if the &#39;expected&#39; value is found.
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toContain'</span>, <span class="keyword">function</span>(expected) {
      <span class="keyword">return</span> recursiveComparison(expression, expected, <span class="literal">false</span>);
    }, <span class="keyword">function</span>(expected) {
      <span class="keyword">return</span> recursiveComparison(expression, expected, <span class="literal">true</span>);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>The &#39;toThrow&#39; matcher catches the exception the &#39;expression&#39; throws when executed.
&#39;not.toThrow&#39; expects no exception to be thrown when the &#39;expression&#39; is executed.
The match passes if no exception is thrown.
returns itself for chaining</p>
<p>A failed match throws a failed object with actual and expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    addMatcher(<span class="string">'toThrow'</span>, <span class="keyword">function</span>(expected) {
      <span class="keyword">try</span> {
        expression();
      } <span class="keyword">catch</span> (e) {
        <span class="keyword">return</span> prototype;
      }
      failed.message = <span class="string">"Expected "</span> + expression + <span class="string">" to throw exception "</span> + expected;
      failed.expected = expected;
      <span class="keyword">throw</span> failed;
    }, <span class="keyword">function</span>(expected) {
      <span class="keyword">try</span> {
        expression();
      } <span class="keyword">catch</span> (e) {
        failed.message = <span class="string">"Expected "</span> + expression + <span class="string">" not to throw exception "</span> + expected;
        failed.expected = expected;
        <span class="keyword">throw</span> failed;
      }
      <span class="keyword">return</span> prototype;
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Returns reference to the ExpectJS object with all the defined matchers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> prototype;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Immediately invoke the function expression to define the expect object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}).call(<span class="keyword">this</span>);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
  <div id="mocha">
    <h1 class="header" >ExpectJS test suite</h1>
  </div>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script>mocha.setup('bdd');</script>
  <script src="../expect.js"></script>
  <script src="../tests/test.js"></script>
  <script>
    // Mocha highlights everything in the document, instead of just content in the #mocha div
    // Fixed by hardcoding mocha as root, but should use the configured root if made into a patch
    function highlight(js) {
      return js
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\/\/(.*)/gm, '<span class="comment">//$1</span>')
        .replace(/('.*?')/gm, '<span class="string">$1</span>')
        .replace(/(\d+\.\d+)/gm, '<span class="number">$1</span>')
        .replace(/(\d+)/gm, '<span class="number">$1</span>')
        .replace(/\bnew *(\w+)/gm, '<span class="keyword">new</span> <span class="init">$1</span>')
        .replace(/\b(function|new|throw|return|var|if|else)\b/gm, '<span class="keyword">$1</span>')
    }

    Mocha.utils.highlightTags = function(name) {
      var code = document.getElementById("mocha").getElementsByTagName(name);
      for (var i = 0, len = code.length; i < len; ++i) {
        code[i].innerHTML = highlight(code[i].innerHTML);
      }
    };

    var runner = mocha.run();
    // runner.globals(['foo', 'bar', 'baz']);

    // runner.on('test end', function(test){
    // console.log(test.fullTitle());
    // });
  </script>
</body>
</html>
